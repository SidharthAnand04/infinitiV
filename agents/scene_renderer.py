import os
import json
import logging
from typing import List, Dict, Any
import shutil
import subprocess

logger = logging.getLogger(__name__)

class SceneRenderer:
    """Scene rendering agent using Ren'Py engine"""
    
    def __init__(self):
        self.renpy_sdk_path = os.getenv('RENPY_SDK_PATH', '')
        self.output_dir = "rendered_scenes"
        self.project_dir = "renpy_projects"
        
        # Create necessary directories
        os.makedirs(self.output_dir, exist_ok=True)
        os.makedirs(self.project_dir, exist_ok=True)
    
    def render_scene(self, script: List[Dict], audio_files: Dict[str, str]) -> Dict[str, Any]:
        """
        Render the scene using Ren'Py engine
        Returns information about the rendered scene
        """
        try:
            logger.info("Starting scene rendering with Ren'Py")
            
            # Create project name based on script content
            project_name = self._generate_project_name(script)
            project_path = os.path.join(self.project_dir, project_name)
            
            # Create Ren'Py project structure
            self._create_renpy_project(project_path, script, audio_files)
            
            # Generate Ren'Py script
            renpy_script = self._generate_renpy_script(script, audio_files)
            
            # Write script file
            script_file = os.path.join(project_path, "game", "script.rpy")
            with open(script_file, "w", encoding="utf-8") as f:
                f.write(renpy_script)
            
            # Try to build/export the scene
            scene_output = self._build_scene(project_path, project_name)
            
            return {
                "project_name": project_name,
                "project_path": project_path,
                "script_file": script_file,
                "scene_output": scene_output,
                "status": "success"
            }
            
        except Exception as e:
            logger.error(f"Error in scene rendering: {str(e)}")
            return self._create_fallback_scene(script, audio_files)
    
    def _generate_project_name(self, script: List[Dict]) -> str:
        """Generate a unique project name based on script content"""
        
        # Extract some text from the script for naming
        text_parts = []
        for block in script[:3]:  # Use first 3 blocks
            if block.get("type") == "dialogue":
                text = block.get("text", "")
                words = text.split()[:3]  # First 3 words
                text_parts.extend(words)
        
        if text_parts:
            project_name = "_".join(text_parts).lower()
            # Clean the name
            project_name = "".join(c for c in project_name if c.isalnum() or c == "_")
            return project_name[:20]  # Limit length
        
        return "infiniti_v_scene"
    
    def _create_renpy_project(self, project_path: str, script: List[Dict], audio_files: Dict[str, str]):
        """Create the basic Ren'Py project structure"""
        
        # Create directory structure
        game_dir = os.path.join(project_path, "game")
        images_dir = os.path.join(game_dir, "images")
        audio_dir = os.path.join(game_dir, "audio")
        
        os.makedirs(game_dir, exist_ok=True)
        os.makedirs(images_dir, exist_ok=True)
        os.makedirs(audio_dir, exist_ok=True)
        
        # Copy audio files to project
        for block_id, audio_file in audio_files.items():
            if os.path.exists(audio_file):
                target_file = os.path.join(audio_dir, f"voice_{block_id}.mp3")
                try:
                    if audio_file.endswith('.txt'):
                        # For simulated audio files, create a placeholder
                        with open(target_file.replace('.mp3', '.txt'), 'w') as f:
                            f.write(f"Audio placeholder for block {block_id}")
                    else:
                        shutil.copy2(audio_file, target_file)
                except Exception as e:
                    logger.warning(f"Could not copy audio file {audio_file}: {str(e)}")
        
        # Create basic options.rpy
        options_content = '''
## This file contains options that can be changed to customize your game.

## Graphics ################################################################

## These options control the width and height of the screen.
define config.screen_width = 1920
define config.screen_height = 1080

## The title of the game.
define config.name = _("∞-V Generated Scene")

## The version of the game.
define config.version = "1.0"

## Text that is placed on the game's about screen.
define gui.about = _p("""
Generated by ∞-V (Infiniti-V)
AI-Powered Animated Video Generator
""")

## A short name for the game used for executables and directories.
define build.name = "infiniti_v_scene"

## Sounds and music ########################################################

## These three variables control which mixers are shown to the player by
## default. Setting one of these to False will hide the appropriate mixer.

define config.has_sound = True
define config.has_music = True
define config.has_voice = True

## Uncomment the following line to set up a main menu music.
# define config.main_menu_music = "music/main_menu.ogg"

## Transitions #############################################################

## These variables set transitions that are used when certain events occur.

define config.enter_transition = dissolve
define config.exit_transition = dissolve
define config.intra_transition = dissolve
define config.after_load_transition = None
define config.end_game_transition = None

## Window management #######################################################

define config.window = "auto"
define config.window_show_transition = Dissolve(.2)
define config.window_hide_transition = Dissolve(.2)

## Preference defaults #####################################################

default preferences.text_cps = 30
default preferences.auto_forward_time = 15

## Save directory ##########################################################

define config.save_directory = "infiniti_v_scene"
'''
        
        with open(os.path.join(game_dir, "options.rpy"), "w", encoding="utf-8") as f:
            f.write(options_content)
        
        # Create basic GUI configuration
        gui_content = '''
## GUI Configuration ######################################################

## Colors ##################################################################
define gui.accent_color = '#0066cc'
define gui.idle_color = '#888888'
define gui.hover_color = '#66b3ff'
define gui.selected_color = '#ffffff'
define gui.insensitive_color = '#8888887f'

## Fonts ###################################################################
define gui.default_font = "DejaVuSans.ttf"
define gui.name_font = "DejaVuSans-Bold.ttf"
define gui.interface_font = "DejaVuSans.ttf"

## Text #####################################################################
define gui.text_size = 22
define gui.name_text_size = 30
define gui.interface_text_size = 22
'''
        
        with open(os.path.join(game_dir, "gui.rpy"), "w", encoding="utf-8") as f:
            f.write(gui_content)
    
    def _generate_renpy_script(self, script: List[Dict], audio_files: Dict[str, str]) -> str:
        """Generate the Ren'Py script content"""
        
        renpy_script = '''# ∞-V Generated Scene Script
# This script was automatically generated by Infiniti-V

# Define characters
'''
        
        # Extract unique characters from script
        characters = set()
        for block in script:
            if block.get("type") == "dialogue":
                character = block.get("character", "narrator")
                characters.add(character)
        
        # Define characters in Ren'Py format
        for character in characters:
            char_name = character.lower().replace(" ", "_")
            if char_name == "narrator":
                renpy_script += f'define {char_name} = Character(None, kind=nvl)\n'
            else:
                renpy_script += f'define {char_name} = Character("{character}")\n'
        
        renpy_script += '\n# Main scene\nlabel start:\n\n'
        
        # Add scene setup
        renpy_script += '    scene bg black\n'
        renpy_script += '    with fade\n\n'
        renpy_script += '    "Welcome to this ∞-V generated scene!"\n\n'
        
        # Process script blocks
        for block in script:
            block_id = block.get("id", "")
            block_type = block.get("type", "")
            
            if block_type == "dialogue":
                character = block.get("character", "narrator")
                text = block.get("text", "")
                
                # Clean character name for Ren'Py
                char_name = character.lower().replace(" ", "_")
                
                # Add voice file if available
                if block_id in audio_files:
                    audio_file = audio_files[block_id]
                    audio_filename = os.path.basename(audio_file)
                    if audio_filename.endswith('.txt'):
                        # For simulated audio, just add the dialogue
                        renpy_script += f'    {char_name} "{text}"\n\n'
                    else:
                        renpy_script += f'    voice "audio/{audio_filename}"\n'
                        renpy_script += f'    {char_name} "{text}"\n\n'
                else:
                    renpy_script += f'    {char_name} "{text}"\n\n'
            
            elif block_type == "action":
                description = block.get("description", "")
                # Convert action to Ren'Py comment or scene direction
                renpy_script += f'    # Action: {description}\n'
                renpy_script += '    with dissolve\n\n'
        
        # End the scene
        renpy_script += '    "Scene complete!"\n'
        renpy_script += '    return\n'
        
        return renpy_script
    
    def _build_scene(self, project_path: str, project_name: str) -> Dict[str, Any]:
        """Attempt to build the Ren'Py scene"""
        
        try:
            if self.renpy_sdk_path and os.path.exists(self.renpy_sdk_path):
                # Try to build with Ren'Py SDK
                return self._build_with_renpy_sdk(project_path, project_name)
            else:
                # Create a simple HTML preview instead
                return self._create_html_preview(project_path, project_name)
                
        except Exception as e:
            logger.error(f"Error building scene: {str(e)}")
            return {"status": "error", "message": str(e)}
    
    def _build_with_renpy_sdk(self, project_path: str, project_name: str) -> Dict[str, Any]:
        """Build the scene using Ren'Py SDK"""
        
        try:
            # This would call the Ren'Py SDK to build the project
            # For now, we'll create a placeholder
            logger.info("Ren'Py SDK build would happen here")
            
            return {
                "type": "renpy_project",
                "project_path": project_path,
                "playable": True,
                "preview_url": f"file://{project_path}/index.html"
            }
            
        except Exception as e:
            logger.error(f"Ren'Py SDK build failed: {str(e)}")
            return self._create_html_preview(project_path, project_name)
    
    def _create_html_preview(self, project_path: str, project_name: str) -> Dict[str, Any]:
        """Create an HTML preview of the scene"""
        
        try:
            # Read the generated script
            script_file = os.path.join(project_path, "game", "script.rpy")
            with open(script_file, "r", encoding="utf-8") as f:
                script_content = f.read()
            
            # Create HTML preview
            html_content = f'''
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>∞-V Scene Preview: {project_name}</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
        }}
        .scene-container {{
            background-color: #2a2a2a;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }}
        .dialogue {{
            margin: 15px 0;
            padding: 10px;
            background-color: #3a3a3a;
            border-radius: 5px;
        }}
        .character-name {{
            font-weight: bold;
            color: #66b3ff;
            margin-bottom: 5px;
        }}
        .action {{
            font-style: italic;
            color: #cccccc;
            margin: 10px 0;
            padding: 5px;
            background-color: #404040;
            border-radius: 3px;
        }}
        .header {{
            text-align: center;
            margin-bottom: 30px;
        }}
        .renpy-script {{
            background-color: #1e1e1e;
            padding: 20px;
            border-radius: 5px;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            overflow-x: auto;
        }}
    </style>
</head>
<body>
    <div class="header">
        <h1>∞-V Scene Preview</h1>
        <h2>{project_name}</h2>
        <p>Generated by Infiniti-V AI Video Generator</p>
    </div>
    
    <div class="scene-container">
        <h3>Scene Preview</h3>
        <p>This is a preview of your generated scene. In the full version, this would be an interactive Ren'Py visual novel.</p>
        
        <div id="scene-content">
            <!-- Scene content will be populated by JavaScript -->
        </div>
    </div>
    
    <div class="scene-container">
        <h3>Generated Ren'Py Script</h3>
        <div class="renpy-script">{script_content}</div>
    </div>
    
    <script>
        // Simple scene preview functionality
        document.addEventListener('DOMContentLoaded', function() {{
            const sceneContent = document.getElementById('scene-content');
            
            // This would normally parse the Ren'Py script and create interactive content
            sceneContent.innerHTML = '<p><em>Interactive scene preview would appear here...</em></p>';
        }});
    </script>
</body>
</html>
'''
            
            # Save HTML preview
            preview_file = os.path.join(project_path, "preview.html")
            with open(preview_file, "w", encoding="utf-8") as f:
                f.write(html_content)
            
            return {
                "type": "html_preview",
                "preview_file": preview_file,
                "preview_url": f"file://{os.path.abspath(preview_file)}",
                "playable": False,
                "project_path": project_path
            }
            
        except Exception as e:
            logger.error(f"Error creating HTML preview: {str(e)}")
            return {"status": "error", "message": str(e)}
    
    def _create_fallback_scene(self, script: List[Dict], audio_files: Dict[str, str]) -> Dict[str, Any]:
        """Create a fallback scene when rendering fails"""
        
        try:
            # Create a simple text-based scene summary
            fallback_dir = os.path.join(self.output_dir, "fallback")
            os.makedirs(fallback_dir, exist_ok=True)
            
            summary_file = os.path.join(fallback_dir, "scene_summary.txt")
            with open(summary_file, "w", encoding="utf-8") as f:
                f.write("∞-V Generated Scene Summary\n")
                f.write("=" * 30 + "\n\n")
                
                for i, block in enumerate(script, 1):
                    f.write(f"Block {i} (ID: {block.get('id', 'unknown')}):\n")
                    
                    if block.get("type") == "dialogue":
                        character = block.get("character", "Unknown")
                        text = block.get("text", "")
                        emotion = block.get("emotion", "neutral")
                        f.write(f"  Character: {character} ({emotion})\n")
                        f.write(f"  Dialogue: \"{text}\"\n")
                        
                        # Note audio file if available
                        block_id = block.get("id", "")
                        if block_id in audio_files:
                            f.write(f"  Audio: {audio_files[block_id]}\n")
                    
                    elif block.get("type") == "action":
                        description = block.get("description", "")
                        f.write(f"  Action: {description}\n")
                    
                    f.write("\n")
            
            return {
                "type": "fallback",
                "summary_file": summary_file,
                "status": "fallback_created",
                "message": "Scene rendering failed, created text summary instead"
            }
            
        except Exception as e:
            logger.error(f"Error creating fallback scene: {str(e)}")
            return {
                "status": "error",
                "message": f"Complete rendering failure: {str(e)}"
            }
